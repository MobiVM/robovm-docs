== Getting Started

In this section you'll learn how to install RoboVM and make sure the toolchain
works correctly by creating a very simple demo app.

TIP: Wanna run RoboVM on Linux? You can build Linux console apps using RoboVM
at this time. Please see the
https://github.com/robovm/robovm/wiki/Get-started-on-Linux[RoboVM GitHub wiki]
for instructions.

[id="prerequisits"]
=== Prerequisites

In order to use RoboVM the following is required:

* A Mac running Mac OS X {osxversion} or later
* http://www.oracle.com/technetwork/java/javase/downloads/index.html[Oracle's
  Java SE JDK 7] or later
* https://itunes.apple.com/us/app/xcode/id497799835?mt=12[Xcode {xcodeversion} from the
  Mac App Store]

NOTE: The first time you install Xcode and every time you update to a new
version you have to open it once to agree to the Xcode terms.

NOTE: To be able to test and deploy your apps on your devices, you will need
an active subscription with the Apple Developer Program. Visit the
https://developer.apple.com/register/index.action[Apple Developer Portal] to
sign up. You will also need to provision your device for development. You can
find information on device provisioning in the Apple Developer Portal, or
follow http://www.bignerdranch.com/we-teach/how-to-prepare/ios-device-provisioning/[this guide]

include::getting-started-eclipse.adoc[]

include::getting-started-idea.adoc[]

include::getting-started-maven.adoc[]

include::getting-started-gradle.adoc[]

=== Project & Code Structure

Whatever method you chose to create your first RoboVM app, the project's
structure will always resemble this layout, plus or minus the files your IDE
or build system generated.

[[img-eclipse-project]]
.Basic iOS project in Eclipse
image::eclipse-project.png[]

Here's a basic run-down of the project's contents:

* `src/main/java/` is where your sources live
* `resources/` contains your app's icons, launch screens and any other assets your app requires
* `robovm.properties` let's you quickly set attributes of your app, such as the main class or app id. Values in this file will get replaced in the two files described below.
* `robovm.xml` let's you specify the <<config-reference,RoboVM specific configuration>> of your app
* `Info.plist.xml` let's you specify the https://developer.apple.com/library/mac/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW1[iOS specific configuration] of your app, such as supported screen orientations

Let's take a quick look at the code itself!

==== The Main Entry Point

Every app has a main entry point. We specify the main class in the
`robovm.properties` file:

[source]
-----
app.version=1.0
app.id=com.mycompany.myapp
app.mainclass=com.mycompany.myapp.HelloRoboVM // <1>
app.executable=HelloRoboVM
app.build=1
app.name=Hello RoboVM
-----

<1> The class is given via its fully qualified class name, including the package it resides in.

When your app is run on the simulator or on a device, the main class' `main
method will be called on startup.

[source,java]
-----
public class HelloRoboVM extends UIApplicationDelegateAdapter { // <4>
    private UIWindow window;
    private MyViewController rootViewController;

    @Override
    public boolean didFinishLaunching (UIApplication application, // <3>
				       UIApplicationLaunchOptions launchOptions) {        
        rootViewController = new MyViewController();
        
        window = new UIWindow(UIScreen.getMainScreen().getBounds());        
        window.setRootViewController(rootViewController);        
        window.makeKeyAndVisible();

        return true;
    }

    public static void main (String[] args) {
        try (NSAutoreleasePool pool = new NSAutoreleasePool()) { // <1>
            UIApplication.main(args, null, HelloRoboVM.class); // <2>
        }
    }
}
-----

<1> Upon entering the `main` method, we setup an https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html[`NSAutoreleasePool`]. It's responsible for managing the life-time of all native Objective-C objects your app interacts with. The autorelease pool will automatically free the memory of any object that is no longer referenced.

<2> We then call https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/[`UIApplication.main`], telling it about our main class, `HelloRoboVM`. This method is responsible for kicking off the user interface, it will never return. Once it is done launching our app, it will call the `didFinishLaunching` method.

<3> In `didFinishLaunching` we setup our basic UI. iOS apps are usually composed of a single `UIWindow` on which we set a root `UIViewController`. The view controller is responsible for setting up user interface elements like labels, buttons and so forth, and reacting to any events on those elements.

<4> Note how `HelloRoboVM` extends from `UIApplicationDelegateAdapter`. We are essentially implementing the Objective-C https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/[`UIApplicationDelegate`] protocol, in Java, which defines methods the `UIApplication` calls when application-level events happen. RoboVM let's us easily extend native Objective-C classes or implement Objective-C protocols!

Let's take a look at the `MyViewController` class, the work horse of our
application.

NOTE: iOS UIs can be created programmatically, as demonstrated here, or graphically, using XCode's https://developer.apple.com/xcode/interface-builder/[Interface Builder]. RoboVM currently only supports the programmatic creation of user interfaces. We'll provide Interface Builder integration in Q2 2015.

==== The View Controller

View controllers are a simple way of managing individual screens of your app.
A view controller usually sets up the UI controls of a specific screen,
registers listeners for events such as button touches, and then reacts to
these events. The `UIWindow` has a single root view controller, which itself
can manage other view controllers.

In our simple app, we have only one view controller, which we set as the root
view controller on the window in `HelloRoboVM#didFinishLaunching`.

[source,java]
-----
public class MyViewController extends UIViewController { // <1>
    private final UIButton button;
    private final UILabel label;
    private int clickCount;

    public MyViewController () { //<2>
        UIView view = getView();

        view.setBackgroundColor(UIColor.white());

        label = new UILabel(new CGRect(20, 250, 280, 44)); // <3>
        label.setFont(UIFont.getSystemFont(24));
        label.setTextAlignment(NSTextAlignment.Center);
        view.addSubview(label);

        button = UIButton.create(UIButtonType.RoundedRect); // <4>
        button.setFrame(new CGRect(110, 150, 100, 40));
        button.setTitle("Click me!", UIControlState.Normal);
        button.getTitleLabel().setFont(UIFont.getBoldSystemFont(22));

        button.addOnTouchUpInsideListener(new UIControl.OnTouchUpInsideListener() { // <5>
            @Override
            public void onTouchUpInside (UIControl control, UIEvent event) {
                label.setText("Click Nr. " + (++clickCount));
            }
        });
        view.addSubview(button);
    }
}
-----

<1> Our `MyViewController` subclasses the Objective-C https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/[`UIViewController`] class.
<2> In its constructor, we setup a label and a button, which we add to the controller's https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/[`UIView`]. The `UIView` is responsible for rendering any content in its area and also handle interactions with that content. In this case, the `UIView` covers the whole `UIWindow`.
<3> To setup a label, we instantiate a https://developer.apple.com/library/ios/documentation/UIKit/Reference/UILabel_Class/[`UILabel`], another Objective-C class, set its size and content, and add it as a sub view to our controllers view.
<4> We do the same for the button of our screen, with one slight twist!
<5> Since we want to react to button touches, we also register a touch listener with the button. Any time a user lifts her finger from the button, we get called back, informing us about this event. Note that the callback originates from native code. RoboVM transparently manages the transition between Java and native code for us!

And here's what our resulting app looks like on the simulator after some heavy button clicking.

[[img-eclipse-demo-app]]
.Our marvelous demo app
image::eclipse-demo-app.png[]

=== Where to go from here? 

Now that you have a basic understanding of how to
use RoboVM with your development environment of choice, it's time to learn
more about writing apps with RoboVM!

. Read the rest of this user guide
. Check out the <<samples, sample projects>> on https://github.com/robovm/robovm-samples[Github]
. Learn from Apple's https://developer.apple.com/library/ios/navigation/#section=Resource%20Types&topic=Guides[iOS Developer Library]